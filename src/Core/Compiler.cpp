#include "Compiler.hpp"
#include <CommandUtils.hpp>
#include <stdexcept>
#include <fstream>
#include "FilesystemUtils.hpp"

static std::string to_string(Compiler::Standard standard) {
    switch (standard) {
        case Compiler::Standard::ASM: return "ASM";
        case Compiler::Standard::C89: return "C89";
        case Compiler::Standard::C99: return "C99";
        case Compiler::Standard::C11: return "C11";
        case Compiler::Standard::C17: return "C17";
        case Compiler::Standard::C23: return "C23";
        case Compiler::Standard::CPP98: return "C++98";
        case Compiler::Standard::CPP03: return "C++03";
        case Compiler::Standard::CPP11: return "C++11";
        case Compiler::Standard::CPP14: return "C++14";
        case Compiler::Standard::CPP17: return "C++17";
        case Compiler::Standard::CPP20: return "C++20";
        case Compiler::Standard::CPP23: return "C++23";
        default: return "Unknown";
    }
}

static std::string get_standard_compile_flag(Compiler::Type type, Compiler::Standard standard) {
    if (type == Compiler::Type::GNU || type == Compiler::Type::CLANG) {
        switch (standard) {
            case Compiler::Standard::C89: return "-std=c89";
            case Compiler::Standard::C99: return "-std=c99";
            case Compiler::Standard::C11: return "-std=c11";
            case Compiler::Standard::C17: return "-std=c17";
            case Compiler::Standard::C23: return "-std=c23";
            case Compiler::Standard::CPP98: return "-std=c++98";
            case Compiler::Standard::CPP03: return "-std=c++03";
            case Compiler::Standard::CPP11: return "-std=c++11";
            case Compiler::Standard::CPP14: return "-std=c++14";
            case Compiler::Standard::CPP17: return "-std=c++17";
            case Compiler::Standard::CPP20: return "-std=c++20";
            case Compiler::Standard::CPP23: return "-std=c++2b";
            default: throw std::runtime_error("Unsupported standard");
        }
    } else if (type == Compiler::Type::MSVC) {
        // This is autogenerated, some standards might not be supported
        switch (standard) {
            case Compiler::Standard::C99: return "/std:c99";
            case Compiler::Standard::C11: return "/std:c11";
            case Compiler::Standard::C17: return "/std:c17";
            case Compiler::Standard::CPP11: return "/std:c++11";
            case Compiler::Standard::CPP14: return "/std:c++14";
            case Compiler::Standard::CPP17: return "/std:c++17";
            case Compiler::Standard::CPP20: return "/std:c++20";
            default: throw std::runtime_error("Unsupported standard");
        }
    } else if (type == Compiler::Type::IAR) {
        // This is autogenerated, some standards might not be supported
        switch (standard) {
            case Compiler::Standard::CPP14: return "--c++";
            // case Compiler::Standard::CPP17: return "--cpp17"; // check IAR version
            default: throw std::runtime_error("Unsupported standard");
        }
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

Compiler::~Compiler() { Log.trace("Delete {} Compiler", to_string(get_language())); }

Compiler::Compiler(Language language,
                   const std::string& location,
                   const std::string& standard_num,
                   bool known_good,
                   const std::string& known_version) :
    m_language(language), m_location(location) {
    Log.trace("Create {} compiler \"{}\" with standard \"{}\"", to_string(get_language()), get_location(), standard_num);

    if (!known_good && !is_valid_program(get_location())) {
        Log.error("{} Compiler \"{}\" not found", to_string(get_language()), get_location());
        throw std::runtime_error("Compiler not found");
    }

    const auto compiler_version_string = known_version.empty() ? get_program_version_string(get_location()) : known_version;

    if (compiler_version_string.contains("GNU") || compiler_version_string.contains("gcc") || compiler_version_string.contains("g++")) {
        m_type = Type::GNU;
        m_flags.push_back("-fdiagnostics-color=always");
        m_flags.push_back("-Dgcc");
        m_flags.push_back("-fmax-errors=10");
    } else if (compiler_version_string.contains("clang")) {
        m_type = Type::CLANG;
        m_flags.push_back("-fdiagnostics-color=always");
    } else if (compiler_version_string.contains("Microsoft")) {
        m_type = Type::MSVC;
        if (get_language() == Language::ASM) {
            throw std::runtime_error("MSVC ASM not implemented");
        }
    } else if (compiler_version_string.contains("IAR")) {
        m_type = Type::IAR;
    } else {
        Log.error("{} Compiler \"{}\" is not supported", to_string(get_language()), get_location());
        Log.info("Version:\n{}", compiler_version_string);
        throw std::runtime_error("Compiler not supported");
    }

    Log.trace(" - Type: {}", to_string(get_type()));

    if (get_language() == Language::ASM) {
        m_standard = Standard::ASM;
    } else if (get_language() == Language::C) {
        if (standard_num == "89" || standard_num == "90") {
            m_standard = Standard::C89;
        } else if (standard_num == "99") {
            m_standard = Standard::C99;
        } else if (standard_num == "11") {
            m_standard = Standard::C11;
        } else if (standard_num == "17") {
            m_standard = Standard::C17;
        } else if (standard_num == "23") {
            m_standard = Standard::C23;
        } else {
            Log.error("Unsupported C standard \"{}\"", standard_num);
            throw std::runtime_error("Unsupported C standard");
        }
    } else if (get_language() == Language::CPP) {
        if (standard_num == "98") {
            m_standard = Standard::CPP98;
        } else if (standard_num == "03") {
            m_standard = Standard::CPP03;
        } else if (standard_num == "11") {
            m_standard = Standard::CPP11;
        } else if (standard_num == "14") {
            m_standard = Standard::CPP14;
        } else if (standard_num == "17") {
            m_standard = Standard::CPP17;
        } else if (standard_num == "20") {
            m_standard = Standard::CPP20;
        } else if (standard_num == "23") {
            m_standard = Standard::CPP23;
        } else {
            Log.error("Unsupported C++ standard \"{}\"", standard_num);
            throw std::runtime_error("Unsupported C++ standard");
        }
    } else {
        Log.error("Unsupported language");
        throw std::runtime_error("Unsupported language");
    }

    Log.trace(" - Standard: {}", to_string(get_standard()));

    if (get_standard() != Standard::ASM) {
        if (get_language() == Language::C && get_type() == Type::IAR) {
            // IAR does not require flag for C
        } else {
            m_flags.push_back(get_standard_compile_flag(get_type(), get_standard()));
        }
    }
}

void Compiler::load_dependency_flags(std::vector<std::string>& flags, const std::filesystem::path& out_path) const {
    if (get_type() == Type::GNU || get_type() == Type::CLANG) {
        flags.push_back("-MMD"); // Generate header dependency list (ignore system headers, but allow user angle brackets)
        flags.push_back("-MF");  // Write to specific file
        flags.push_back(FilesystemUtils::safe_path_string(out_path.string() + ".dep"));
    } else if (get_type() == Type::MSVC) {
        flags.push_back("/showIncludes"); // Generate header dependency list
        flags.push_back("/Fo");           // Write to specific file
        flags.push_back(FilesystemUtils::safe_path_string(out_path.string()));
    } else if (get_type() == Type::IAR) {
        if (get_language() == Language::ASM)
            return;
        flags.push_back("--dependencies"); // Write to specific file
        flags.push_back(FilesystemUtils::safe_path_string(out_path.string() + ".dep"));
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

void Compiler::load_compile_and_output_flags(std::vector<std::string>& flags,
                                             const std::filesystem::path& source_path,
                                             const std::filesystem::path& obj_path,
                                             bool is_pch) const {
    const auto source = FilesystemUtils::safe_path_string(source_path.string());

    if (get_type() == Type::GNU || get_type() == Type::CLANG) {
        flags.push_back("-c"); // Compile only
        flags.push_back(source);
        if (is_pch && get_type() == Type::CLANG) {
            flags.push_back("-emit-pch");
        }
        flags.push_back("-o"); // Write to specific file
        flags.push_back(
            FilesystemUtils::safe_path_string(obj_path.string() + (is_pch ? get_precompile_header_extension() : get_object_extension())));
    } else if (get_type() == Type::MSVC) {
        flags.push_back("/c");  // Compile only
        flags.push_back(source);
        flags.push_back("/Fo"); // Write to specific file
        flags.push_back(obj_path.string());
    } else if (get_type() == Type::IAR) {
        if (get_language() != Language::ASM)
            flags.push_back("--silent"); // Do not generate compile spam
        flags.push_back(source);
        flags.push_back("-o");           // Write to specific file
        flags.push_back(obj_path.string() + ".o");
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

void Compiler::push_include_path(std::vector<std::string>& flags, const std::string& include_directory) const {
    auto inc = FilesystemUtils::safe_path_string(include_directory);
    if (inc.find(' ') != std::string::npos) {
        inc = "\\\"" + inc + "\\\"";
    }

    if (get_type() == Type::GNU || get_type() == Type::CLANG || get_type() == Type::IAR) {
        flags.push_back("-I" + inc);
    } else if (get_type() == Type::MSVC) {
        // do this for MSVC
        flags.push_back("/I");
        flags.push_back(inc);
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

void Compiler::push_compile_definition(std::vector<std::string>& flags, const std::string& compile_definition) const {
    // escape "\" in compile_definition and wrap value after DEFINITION_NAME= in escaped quotes if value contains spaces
    // replace all '"' with "\\"" safely without entering an infinite loop
    std::string escaped_compile_definition = compile_definition;
    // replace all "\\" with "\\\\"
    escaped_compile_definition = replace_string(escaped_compile_definition, "\\", "\\\\");
    // escaped_compile_definition = replace_string(escaped_compile_definition, "\"", "\\\"");

    auto eq_pos     = escaped_compile_definition.find('=');
    std::string def = "";
    if (eq_pos != std::string::npos) {
        auto part_2           = escaped_compile_definition.substr(eq_pos + 1);
        const bool have_space = part_2.find(' ') != std::string::npos;
        if (have_space) {
            if (part_2.starts_with('\"') && part_2.ends_with('\"')) {
                def = escaped_compile_definition.substr(0, eq_pos + 1) + "\"" + part_2.substr(1, part_2.length() - 2) + "\"";
            } else {
                def = escaped_compile_definition.substr(0, eq_pos + 1) + "\"" + part_2 + "\"";
            }
        } else {
            // not very efficient - but undo quoting escape
            if (part_2.starts_with("\\\"") && part_2.ends_with("\\\"")) {
                def = escaped_compile_definition.substr(0, eq_pos + 1) + "\"" + part_2 + "\"";
            } else {
                def = escaped_compile_definition.substr(0, eq_pos + 1) + part_2;
            }
        }
    } else {
        def = escaped_compile_definition;
    }

    if (get_type() == Type::GNU || get_type() == Type::CLANG || get_type() == Type::IAR || get_type() == Type::IAR) {
        flags.push_back("-D" + def);
    } else if (get_type() == Type::MSVC) {
        flags.push_back("/D");
        flags.push_back(def);
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

std::string Compiler::get_object_extension() const {
    if (get_type() == Type::GNU || get_type() == Type::CLANG) {
        return ".o";
    } else if (get_type() == Type::MSVC) {
        return ".obj";
    } else if (get_type() == Type::IAR) {
        return ".o";
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

std::string Compiler::get_dependency_extension() const {
    if (get_type() == Type::GNU || get_type() == Type::CLANG || get_type() == Type::IAR) {
        return ".dep";
    } else if (get_type() == Type::MSVC) {
        throw std::runtime_error("Not implemented");
    } else {
        throw std::runtime_error("Unsupported compiler");
    }

    return "";
}

std::string Compiler::get_precompile_header_extension() const {
    if (get_type() == Type::GNU) {
        return ".gch";
    } else if (get_type() == Type::CLANG) {
        // TODO: functions for compiling and including precompiled headers is different than gcc
        // throw std::runtime_error("Not implemented - need to check docs");
        return ".pch";
    } else if (get_type() == Type::IAR) {
        throw std::runtime_error("Not implemented - not supported, need to find good enough workaround with --preinclude");
    } else if (get_type() == Type::MSVC) {
        throw std::runtime_error("Not implemented");
    } else {
        throw std::runtime_error("Unsupported compiler");
    }

    return "";
}

std::vector<std::string> Compiler::get_stdlib_paths() const {
    if (get_type() == Type::GNU || get_type() == Type::CLANG) {
        std::vector<std::string> args;

#ifdef WINDOWS_BUILD
        static constexpr bool is_windows = true;
#else
        static constexpr bool is_windows = false;
#endif

        if (get_language() == Language::CPP) {
            args = {"-E", "-Wp,-v", "-xc++", is_windows ? "NUL" : "/dev/null"};
        } else if (get_language() == Language::C) {
            args = {"-E", "-Wp,-v", "-xc", is_windows ? "NUL" : "/dev/null"};
        } else {
            throw std::runtime_error("Unsupported language");
        }
        auto [ret, output] = execute_with_args(get_location(), args);
        if (ret) {
            throw std::runtime_error("Failed to get stdlib paths");
        }

        /* Command output:
            # 0 "NUL"
            # 0 "<built-in>"
            # 0 "<command-line>"
            # 1 "NUL"
            ignoring duplicate directory "c:/program files (x86)/arm gnu toolchain arm-none-eabi/12.2 mpacbti-rel1/lib/gcc/../../lib/gcc/arm-none-eabi/12.2.1/include"
            ignoring nonexistent directory "c:\program files (x86)\arm gnu toolchain arm-none-eabi\12.2 mpacbti-rel1\bin\../arm-none-eabi/data/jenkins/workspace/GNU-toolchain/arm-12-mpacbti/build-mingw-arm-none-eabi/install/lib/gcc/arm-none-eabi/12.2.1/../../../../include"
            ignoring duplicate directory "c:/program files (x86)/arm gnu toolchain arm-none-eabi/12.2 mpacbti-rel1/lib/gcc/../../lib/gcc/arm-none-eabi/12.2.1/include-fixed"
            ignoring duplicate directory "c:/program files (x86)/arm gnu toolchain arm-none-eabi/12.2 mpacbti-rel1/lib/gcc/../../lib/gcc/arm-none-eabi/12.2.1/../../../../arm-none-eabi/include"
            ignoring nonexistent directory "c:\program files (x86)\arm gnu toolchain arm-none-eabi\12.2 mpacbti-rel1\bin\../arm-none-eabi/usr/include"
            #include "..." search starts here:
            #include <...> search starts here:
            c:\program files (x86)\arm gnu toolchain arm-none-eabi\12.2 mpacbti-rel1\bin\../lib/gcc/arm-none-eabi/12.2.1/include
            c:\program files (x86)\arm gnu toolchain arm-none-eabi\12.2 mpacbti-rel1\bin\../lib/gcc/arm-none-eabi/12.2.1/include-fixed
            c:\program files (x86)\arm gnu toolchain arm-none-eabi\12.2 mpacbti-rel1\bin\../lib/gcc/arm-none-eabi/12.2.1/../../../../arm-none-eabi/include
            End of search list.
        */
        std::vector<std::string> paths;
        // iterate command output line by line, add paths after "#include <...> search starts here:" to paths vector
        std::string line;
        bool start = false;
        std::stringstream ss_output(output);
        while (std::getline(ss_output, line)) {
            if (start) {
                if (line.starts_with("End of search list.")) {
                    break;
                }
                if (line.starts_with(" ")) {
                    paths.push_back(std::filesystem::weakly_canonical(line.substr(1, line.length() - 2)).string());
                }
            } else {
                if (line.starts_with("#include <...> search starts here:")) {
                    start = true;
                }
            }
        }

        return paths;
    } else if (get_type() == Type::MSVC) {
        throw std::runtime_error("Not implemented (get_stdlib_paths)");
    } else if (get_type() == Type::IAR) {
        return {
            "C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.2\\arm\\inc\\c",
            "C:\\Program Files (x86)\\IAR Systems\\Embedded Workbench 8.2\\arm\\inc\\cpp",
        };
    } else {
        throw std::runtime_error("Unsupported compiler (get_stdlib_paths)");
    }
}

std::string Compiler::get_system_header_pragma() const {
    if (get_type() == Type::GNU) {
        return "#pragma GCC system_header";
    } else if (get_type() == Type::CLANG) {
        return "#pragma clang system_header";
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

std::string Compiler::get_pch_include_flags(const std::filesystem::path& pch_gen_path) const {
    const auto file_path   = FilesystemUtils::safe_path_string(pch_gen_path.string());
    const auto search_path = FilesystemUtils::safe_path_string(pch_gen_path.parent_path().string());

    if (get_type() == Type::GNU) {
        // return "-I" + search_path + " -include " + file_path;
        return "-include " + file_path;
    } else if (get_type() == Type::CLANG) {
        return "-include-pch " + file_path + ".pch";
    } else if (get_type() == Type::IAR) {
        throw std::runtime_error("Not implemented - not supported, need to find good enough workaround with --preinclude");
    } else if (get_type() == Type::MSVC) {
        throw std::runtime_error("Not implemented");
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}

void Compiler::iterate_dependency_file(const std::filesystem::path& dependency_file,
                                       const std::function<bool(std::string_view)>& callback) const {
    std::ifstream dep_file(dependency_file);

    if (get_type() == Type::GNU || get_type() == Type::CLANG) {
        /* Format:
            object/path/obj.o: \
            dep/path/a.cpp \
            dep/path/b.hpp \
            dep/path/c.hpp \
        */
        // Format includes the compiled cpp file as well.
        // TODO: don't check the actual compiled file - other cpp files should be ok to check
        std::string line;
        std::getline(dep_file, line); // skip first line
        while (std::getline(dep_file, line)) {
            // trim line spaces from beginning and remove potential " \" at the end of the line
            const auto backslash_terminated = line.ends_with(" \\");
            std::string_view line_sv(line.data() + line.find_first_not_of(' '),
                                     line.data() + (backslash_terminated ? (line.length() - 2) : line.length()));

            const bool should_return = callback(line_sv);
            if (should_return)
                return;
        }
    } else if (get_type() == Type::IAR) {
        /* Format:
            dep/path/a.hpp
            dep/path/b.hpp
            dep/path/c.hpp
        */
        std::string line;
        while (std::getline(dep_file, line)) {
            if (line.starts_with("C:\\Program Files (x86)\\IAR Systems")) { // Skip IAR system includes
                continue;
            }
            const bool should_return = callback(line);
            if (should_return)
                return;
        }
    } else if (get_type() == Type::MSVC) {
        throw std::runtime_error("Not implemented");
    } else {
        throw std::runtime_error("Unsupported compiler");
    }
}
