#include "Component.hpp"
#include <algorithm>
#include <chrono>
#include <exception>
#include <lua.hpp>
#include <filesystem>
#include <CommandUtils.hpp>
#include <mutex>
#include <ostream>
#include <stdexcept>
#include <vector>
#include <unordered_map>
#include "Core/Archiver.hpp"
#include "Core/Compiler.hpp"
#include "Core/FunctionWorker.hpp"
#include "Core/GIT.hpp"
#include "Core/Linker.hpp"
#include "Core/SourceEntry.hpp"
#include "FilesystemUtils.hpp"
#include "RegexUtils.hpp"
#include <fstream>
#include <sstream>
#include <execution>

#include "LuaBackend.hpp"
#include "lauxlib.h"

extern std::vector<std::filesystem::path> s_script_path_stack;
extern std::vector<std::filesystem::path> s_source_location_stack;

////////////////////////////////////
// File modified cache
static std::unordered_map<size_t, std::filesystem::file_time_type> s_file_modified_cache;
static std::mutex s_mutex_file_modified_cache;

uint32_t s_fmc_hits   = 0;
uint32_t s_fmc_misses = 0;

std::filesystem::file_time_type get_file_modified_time(std::string_view path) {
    const auto hash = std::hash<std::string_view>{}(path);

    std::lock_guard<std::mutex> _lock(s_mutex_file_modified_cache);

    const auto it = s_file_modified_cache.find(hash);
    if (it != s_file_modified_cache.end()) {
        s_fmc_hits++;
        return it->second;
    } else {
        s_fmc_misses++;
        const auto mod_time         = std::filesystem::last_write_time(path);
        s_file_modified_cache[hash] = mod_time;
        return mod_time;
    }
}

////////////////////////////////////

extern std::unordered_map<std::string, std::vector<std::string>> e_global_c_compile_options;
extern std::unordered_map<std::string, std::vector<std::string>> e_global_cpp_compile_options;
extern std::unordered_map<std::string, std::vector<std::string>> e_global_definitions;
extern std::unordered_map<std::string, std::vector<std::filesystem::path>> e_global_include_paths;
extern std::unordered_map<std::string, std::vector<std::string>> e_global_asm_compile_options;
extern std::unordered_map<std::string, std::vector<std::string>> e_global_link_options;

Component::Component(Type type,
                     const std::string& name,
                     const std::filesystem::path& script_path,
                     const std::filesystem::path& root_path,
                     const std::filesystem::path& local_output_directory,
                     const std::string& ns) :
    m_type(type),
    m_name(name),
    m_script_path(std::filesystem::weakly_canonical(script_path)),
    m_root_path(std::filesystem::weakly_canonical(root_path)),
    m_local_output_directory(std::filesystem::weakly_canonical(local_output_directory)),
    m_namespace(ns) {}

Component::~Component() {}

// TODO: move to better location
std::vector<std::string> s_TempFileExtensions = {
    ".o",
    ".dep",
};

static void prepare_and_push_flags(std::vector<std::string>& flags, const std::string& flag) {
    // escape "\" characters and split regular spaces into multiple flags
    std::vector<std::string> split_flags;
    std::string current_flag;
    bool escape_next = false;
    // TODO: validate this bs, generated by copilot, seems to potentially break with \" escaped stuff
    for (const auto& c : flag) {
        if (escape_next) {
            current_flag += c;
            escape_next = false;
        } else if (c == '\\') {
            escape_next = true;
            current_flag += c;
        } else if (c == ' ') {
            split_flags.push_back(current_flag);
            current_flag.clear();
        } else {
            current_flag += c;
        }
    }
    split_flags.push_back(current_flag);
    // push to flags
    for (const auto& f : split_flags) {
        flags.push_back(f);
    }
}

static void try_merge_lib_content(const Compiler* compiler,
                                  std::vector<std::string>& compile_args,
                                  const Component* lib,
                                  Component::Visibility check_visibilities) {
    // include paths
    if (lib->get_visibility_mask_include_paths() & check_visibilities) {
        for (const auto& val : lib->get_include_paths()) {
            if (!(val.visibility & check_visibilities))
                continue;
            compiler->push_include_path(compile_args, val.value.string());
        }
    }
    // compile definitions
    if (lib->get_visibility_mask_definitions() & check_visibilities) {
        for (const auto& val : lib->get_definitions()) {
            if (!(val.visibility & check_visibilities))
                continue;
            compiler->push_compile_definition(compile_args, val.value);
        }
    }
    // append custom options
    if (lib->get_visibility_mask_compile_options() & check_visibilities) {
        for (const auto& val : lib->get_compile_options()) {
            if (!(val.visibility & check_visibilities))
                continue;
            prepare_and_push_flags(compile_args, val.value);
        }
    }
}

static Compiler* get_compiler_from_extension(const std::filesystem::path& path,
                                             std::shared_ptr<Compiler> c_compiler,
                                             std::shared_ptr<Compiler> cpp_compiler,
                                             std::shared_ptr<Compiler> asm_compiler) {
    Compiler* compiler;
    auto ext = path.extension().string();
    // convert ext to lower case
    std::transform(ext.begin(), ext.end(), ext.begin(), [](char c) {
        return std::tolower(c);
    });

    if (ext == ".c" || ext == ".h") {
        compiler = c_compiler.get();
        if (!compiler) {
            Log.error("C Compiler not set");
            throw std::runtime_error("C Compiler not set");
        }
    } else if (ext == ".cpp" || ext == ".hpp" || ext == ".cc" || ext == ".cxx" || ext == ".c++") {
        compiler = cpp_compiler.get();
        if (!compiler) {
            Log.error("C++ Compiler not set");
            throw std::runtime_error("C Compiler not set");
        }
    } else if (ext == ".asm" || ext == ".s") {
        compiler = asm_compiler.get();
        if (!compiler) {
            Log.error("ASM Compiler not set");
            throw std::runtime_error("C Compiler not set");
        }
    } else {
        throw std::runtime_error("Unsupported file type");
    }

    return compiler;
}

std::filesystem::path Component::get_source_output_directory(const SourceFilePath& sfp) {
    if (!sfp.explicit_output_directory.empty())
        return sfp.explicit_output_directory;

    if (sfp.is_external) {
        return get_local_output_directory() / "extern" / std::to_string(std::filesystem::hash_value(sfp.path.parent_path()));
    } else {
        return get_local_output_directory() / std::filesystem::relative(sfp.path.parent_path(), get_root_path());
    }
}

bool Component::process_source_file_path(const SourceFilePath& e,
                                         std::shared_ptr<Compiler> c_compiler,
                                         std::shared_ptr<Compiler> cpp_compiler,
                                         std::shared_ptr<Compiler> asm_compiler,
                                         bool force_compile) {
    const auto output_dir = get_source_output_directory(e);
    const auto* compiler  = get_compiler_from_extension(e.path, c_compiler, cpp_compiler, asm_compiler);

    const bool is_pch   = e.is_precompiled_header_file;
    const auto src_name = e.path.filename().string();
    // path to output build files to
    const auto obj_path =
        output_dir / (src_name + (is_pch ? compiler->get_precompile_header_extension() : compiler->get_object_extension()));

    // do not add precompiled header - it is not actually linked
    if (!is_pch) {
        m_mutex_output_object_paths.lock();
        m_output_object_paths.push_back(obj_path);
        m_mutex_output_object_paths.unlock();
    }

    // temporary and dependency file paths
    const auto dep_path    = output_dir / (src_name + compiler->get_dependency_extension());
    const auto ts_temp     = output_dir / (src_name + ".tmp");
    const auto ts_dep_temp = output_dir / (src_name + ".dep.tmp");

    // initialize output directory for temp and build files
    m_mutex_source_paths.lock();
    if (!std::filesystem::exists(output_dir)) {
        try {
            std::filesystem::create_directories(output_dir);
        } catch (const std::exception& e) {
        }
    }
    m_mutex_source_paths.unlock();

    bool need_build = false;

    if (!FilesystemUtils::all_exist(ts_temp, ts_dep_temp, dep_path, obj_path)) {
        need_build = true;
        // create and write modify empty file ts_temp
        try {
            std::ofstream ts_temp_file(ts_temp);
            ts_temp_file.close();
            std::ofstream ts_dep_temp_file(ts_dep_temp);
            ts_dep_temp_file.close();
        } catch (const std::exception& e) {
            Log.error("[{}] Failed to create timestamp file at \"{}\": {}", get_name(), ts_temp, e.what());
            throw std::runtime_error("Failed to create timestamp file");
        }
    } else {
        auto src_modified_time     = std::filesystem::last_write_time(e.path);  // source file
        auto ts_mark_modified_time = std::filesystem::last_write_time(ts_temp); // modified time tracker

        const bool source_modified = src_modified_time > ts_mark_modified_time;

        if (source_modified) {
            need_build = true;
            // set ts_temp write time to src_modified_time
            try {
                std::filesystem::last_write_time(ts_temp, src_modified_time);
            } catch (const std::exception& e) {
                Log.error("[{}] Failed to set timestamp file \"{}\" time: {}", get_name(), ts_temp, e.what());
                throw std::runtime_error("Failed to set timestamp file time");
            }
        } else {
            const auto ts_dep_modified_time = std::filesystem::last_write_time(ts_dep_temp);

            // iterate deps
            // parse dep_path file
            compiler->iterate_dependency_file(dep_path, [&](std::string_view path) -> bool {
                if (e.path == path)
                    return false; // ignore "this" compile unit
                if (!std::filesystem::exists(path))
                    return false;
                // check if dep file is newer than obj file
                auto dependency_modified_time = get_file_modified_time(path);
                if (dependency_modified_time > ts_dep_modified_time) { // always check to write latest change
                    // set ts_temp write time to src_modified_time
                    try {
                        // std::filesystem::last_write_time(ts_dep_temp, dependency_modified_time);
                        std::ofstream ts_dep_temp_file(ts_dep_temp);
                        ts_dep_temp_file.close();
                    } catch (const std::exception& e) {
                        Log.error("[{}] Failed to set timestamp file \"{}\" time: {}", get_name(), ts_temp, e.what());
                        throw std::runtime_error("Failed to set timestamp file time");
                    }
                    need_build = true;
                    return true; // break
                }

                return false; // dont break
            });
        }
    }

    // return if build is not needed and build is not externally forced
    if (!need_build && !force_compile)
        return false;

    // create compile entry
    auto compile_entry          = std::make_unique<CompileEntry>();
    compile_entry->source_entry = std::make_unique<SourceEntry>(compiler, e.path, output_dir, obj_path, e.is_precompiled_header_file);
    const auto& source_entry    = *compile_entry->source_entry;

    m_mutex_source_paths.lock();
    if (!std::filesystem::exists(source_entry.get_output_directory())) {
        // Generate output_directory if it does not exist
        try {
            std::filesystem::create_directories(source_entry.get_output_directory());
            m_mutex_source_paths.unlock();
        } catch (const std::exception& e) {
            m_mutex_source_paths.unlock();
            Log.error("Failed to create output dir [{}]: {}", source_entry.get_output_directory(), e.what());
            throw e;
        }
    } else {
        m_mutex_source_paths.unlock();
    }

    // path to output build files to
    const auto output_path = source_entry.get_output_directory() / source_entry.get_source_file_path().filename().string();

    // initial args are defined from the specific compiler implementation
    compile_entry->compile_args = compiler->get_options();

    compiler->load_compile_and_output_flags(
        compile_entry->compile_args, source_entry.get_source_file_path(), output_path, source_entry.is_pch()); // compile and write object

    compiler->load_dependency_flags(compile_entry->compile_args, output_path); // dependency file output

    // Compile option replacement setup
    const auto option_replacement = [&](const std::string_view& opt) -> std::string {
        if (is_pch)
            return std::string(opt);

        for (const auto& rep : get_compile_option_replacements()) {
            if (opt == rep.search) {
                const bool is_star = rep.match[0] == '*';
                if (is_star || FilesystemUtils::path_contains(e.path, rep.match)) {
                    return rep.replace;
                }
            }
        }

        return std::string(opt);
    };

    // [Local paths/definitions/options]
    // include paths
    for (const auto& val : get_include_paths()) {
        compiler->push_include_path(compile_entry->compile_args, val.value.string());
    }
    // compile definitions
    for (const auto& val : get_definitions()) {
        compiler->push_compile_definition(compile_entry->compile_args, val.value);
    }
    // append custom options
    if (get_compile_option_replacements().empty()) {
        for (const auto& val : get_compile_options()) {
            prepare_and_push_flags(compile_entry->compile_args, val.value);
        }
    } else {
        for (const auto& val : get_compile_options()) {
            auto v = option_replacement(val.value);
            prepare_and_push_flags(compile_entry->compile_args, v);
        }
    }

    // [Library paths/definitions/options]
    for (const auto* lib : get_libraries()) {
        try_merge_lib_content(compiler, compile_entry->compile_args, lib, Visibility::PUBLIC);
    }

    // Merge global defs
    // include paths
    for (const auto& val : e_global_include_paths[get_namespace()]) {
        compiler->push_include_path(compile_entry->compile_args, val.string());
    }
    // compile definitions
    for (const auto& val : e_global_definitions[get_namespace()]) {
        compiler->push_compile_definition(compile_entry->compile_args, val);
    }
    // append global custom options
    std::vector<std::string>* opts = nullptr;
    switch (compiler->get_language()) {
        case Compiler::Language::C: opts = &e_global_c_compile_options[get_namespace()]; break;
        case Compiler::Language::CPP: opts = &e_global_cpp_compile_options[get_namespace()]; break;
        case Compiler::Language::ASM: opts = &e_global_asm_compile_options[get_namespace()]; break;
        default: opts = nullptr;
    }
    if (opts) {
        if (get_compile_option_replacements().empty()) {
            for (const auto& val : *opts) {
                prepare_and_push_flags(compile_entry->compile_args, val);
            }
        } else {
            for (const auto& val : *opts) {
                auto v = option_replacement(val);
                prepare_and_push_flags(compile_entry->compile_args, v);
            }
        }
    }

    compile_entry->compiler = compiler;

    // write command file @ output_dir/cmd.txt
    const auto dir    = replace_string(compile_entry->source_entry->get_output_directory().string(), "\\", "\\\\");
    const auto source = replace_string(compile_entry->source_entry->get_source_file_path().string(), "\\", "\\\\");
    const auto cmd_p1 = replace_string(container_to_string(compile_entry->compile_args), "\\", "\\\\");
    // make cmd_p1 a valid json string and escape for compiler string macros
    std::string cmd;
    bool second = false;
    for (const auto& c : cmd_p1) {
        if (c == '"') {
            if (second) {
                cmd += "\\\\\\\"\\\"";
            } else {
                cmd += "\\\"\\\\\\\"";
            }
            second = !second;
        } else {
            cmd += c;
        }
    }

    std::ofstream cmd_file(compile_entry->source_entry->get_object_path().string() + ".txt", std::ios::out | std::ios::trunc);
    cmd_file << "{\n";
    cmd_file << ("    \"directory\": \"" + dir + "\",\n");
    cmd_file << ("    \"command\": \"" + compile_entry->compiler->get_location() + " " + cmd + " ${POST_OPTIONS}\",\n");
    cmd_file << ("    \"file\": \"" + source + "\"\n");
    cmd_file << ("},\n");
    cmd_file.close();

    m_mutex_compile_entries.lock();
    m_compile_entries.emplace_back(std::move(compile_entry));
    m_mutex_compile_entries.unlock();
    return true;
}

void Component::configure(std::shared_ptr<Compiler> c_compiler,
                          std::shared_ptr<Compiler> cpp_compiler,
                          std::shared_ptr<Compiler> asm_compiler,
                          std::shared_ptr<Linker> linker,
                          std::shared_ptr<Archiver> archiver) {
    m_linker   = linker;
    m_archiver = archiver;
    Log.info("Configure [{}]", get_name());
    const auto configure_t1 = std::chrono::high_resolution_clock::now();

    // Add requested sources to path vector
    auto source_file_paths = get_source_file_paths();

    const auto& pch = get_precompiled_header();
    // XXX: TEMPORARY:
    bool have_cpp_files = false;
    for (auto& s : m_requested_sources) {
        if (s.ends_with(".cpp")) {
            have_cpp_files = true;
            break;
        }
    }

    bool pch_updated = false;
    if (!pch.empty()) {
        const auto* compiler    = have_cpp_files ? cpp_compiler.get() : c_compiler.get();
        const auto pch_name     = have_cpp_files ? "pch.hpp" : "pch.h";
        const auto output_dir   = get_local_output_directory() / "pch";
        const auto output_obj   = output_dir / (pch_name + compiler->get_precompile_header_extension());
        const auto gen_src_path = output_dir / pch_name;

        if (!std::filesystem::exists(output_dir))
            std::filesystem::create_directories(output_dir);

        std::stringstream gen_src;
        gen_src << "// cfxs-build precompile header file" << std::endl;
        // TODO: check how to fix this line generating a "#pragma system_header ignored outside include file" warning
        // gen_src << compiler->get_system_header_pragma() << std::endl;
        for (const auto& inc : pch) {
            gen_src << "#include " << inc << std::endl;
        }
        gen_src << std::endl;

        bool need_update_pch = true;
        if (FilesystemUtils::all_exist(gen_src_path, output_obj)) {
            // check if gen_src is byte-byte equal to file at gen_src_path
            std::ifstream gen_src_file(gen_src_path);
            std::stringstream gen_src_file_stream;
            gen_src_file_stream << gen_src_file.rdbuf();
            gen_src_file.close();
            need_update_pch = gen_src_file_stream.str() != gen_src.str();
        }

        if (need_update_pch) {
            Log.debug("[{}] Write PCH", get_name());
            std::ofstream gen_src_file(gen_src_path);
            gen_src_file << gen_src.rdbuf();
            gen_src_file.close();
            pch_updated = true;
        }

        SourceFilePath sfp(gen_src_path, false, output_dir, true);
        const bool added = process_source_file_path(sfp, c_compiler, cpp_compiler, asm_compiler, need_update_pch);
        if (added)
            pch_updated = true;

        // Add pch flag
        // TODO: proper compiler check
        if ((compiler->get_type() == Compiler::Type::GNU) || (compiler->get_type() == Compiler::Type::CLANG))
            m_compile_options.emplace_back(Visibility::PRIVATE, "-Winvalid-pch");
        m_compile_options.emplace_back(Visibility::PRIVATE, compiler->get_pch_include_flags(gen_src_path));
    }

    // iterate all sources
    std::for_each(std::execution::par, source_file_paths.begin(), source_file_paths.end(), [&](const SourceFilePath& e) {
        process_source_file_path(e, c_compiler, cpp_compiler, asm_compiler, pch_updated);
    });

    const auto configure_t2 = std::chrono::high_resolution_clock::now();
    auto configure_ms       = std::chrono::duration_cast<std::chrono::milliseconds>(configure_t2 - configure_t1).count();
    Log.trace("Configure done in {:.3}s", configure_ms / 1000.0f);
}

void Component::clean() {
    Log.info("Clean [{}] @ {}", get_name(), get_local_output_directory());
    const auto clean_t1 = std::chrono::high_resolution_clock::now();

    if (!std::filesystem::exists(get_local_output_directory()))
        return;

    // recursively remove all temp files from get_local_output_directory()
    for (const auto& entry : std::filesystem::recursive_directory_iterator(get_local_output_directory())) {
        if (std::find(s_TempFileExtensions.begin(), s_TempFileExtensions.end(), entry.path().extension()) != s_TempFileExtensions.end()) {
            const bool removed = std::filesystem::remove(entry.path());
            if (!removed) {
                Log.error("Failed to delete {}", entry.path());
                throw std::runtime_error("Failed to delete file");
            } else {
                Log.trace(" - Delete {}", entry.path());
            }
        }
    }

    const auto clean_t2 = std::chrono::high_resolution_clock::now();
    auto clean_ms       = std::chrono::duration_cast<std::chrono::milliseconds>(clean_t2 - clean_t1).count();
    Log.trace("Clean done in {:.3}s", clean_ms / 1000.0f);
}

static std::pair<int, std::string> s_compile(const std::unique_ptr<CompileEntry>& ce) {
    return execute_with_args(ce->compiler->get_location(), ce->compile_args);
}

void Component::iterate_libs(const Component* comp, std::vector<std::string>& list) {
    for (const auto* lib : comp->get_libraries()) {
        if (lib->get_type() == Type::LIBRARY) {
            const auto lib_path =
                lib->get_local_output_directory() / (lib->get_name() + std::string(lib->m_archiver->get_archive_extension()));
            list.push_back(lib_path.string());
            iterate_libs(lib, list);

            for (const auto& a : lib->get_additional_libraries()) {
                list.push_back(a);
            }
        }
    }
}

extern int e_total_project_source_count;
extern int e_current_abs_source_index;
std::mutex s_source_index_mutex;

void Component::build() {
    const auto build_t1 = std::chrono::high_resolution_clock::now();

    bool lib_was_built = false;
    for (auto& lib : get_libraries()) {
        if (lib->did_build()) {
            lib_was_built = true;
            break;
        }
    }

    // return if have final build object and configure did not request source build
    if (get_type() == Type::LIBRARY) {
        if (!lib_was_built) {
            const auto library_path = get_local_output_directory() / (get_name() + std::string(m_archiver->get_archive_extension()));
            if (std::filesystem::exists(library_path)) {
                if (get_compile_entries().empty())
                    return;
            }
        }
        // mark self as built
        set_did_build();
    } else {
            // check if a library was built. If so, dont allow skip (for linking)
            if (!lib_was_built) {
            const auto exe_path = get_local_output_directory() / (get_name() + std::string(m_linker->get_executable_extension()));
            if (std::filesystem::exists(exe_path)) {
                if (get_compile_entries().empty())
                    return;
            }
        }
    }

    const auto& compile_entries = get_compile_entries();

    if (!compile_entries.empty()) {
        Log.trace("Build [{}]", get_name());

        bool error_reported = false; // a source has reported a failed compilation

        const auto compile = [&](const std::unique_ptr<CompileEntry>& compile_entry) {
            if (error_reported)
                return;
            const auto t_start = std::chrono::high_resolution_clock::now();

            const auto [ret, msg] = s_compile(compile_entry);

            // don't show successful outputs from commands after the first failed one
            const bool success = ret == 0;
            if (success && error_reported)
                return;

            const auto t_end           = std::chrono::high_resolution_clock::now();
            const auto compile_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(t_end - t_start).count();

            // show full source path on fail and only filename on success
            const auto compile_unit_path = success ? compile_entry->source_entry->get_source_file_path().filename().string() :
                                                     compile_entry->source_entry->get_source_file_path().string();

            s_source_index_mutex.lock();
            auto si = e_current_abs_source_index++;
            Log.info("[{}{}/{} ({}%) {:.03f}s{}] ({}{}{}) {} {}{}{}{}" ANSI_RESET,
                     success ? ANSI_GREEN : ANSI_RED,
                     si,
                     e_total_project_source_count,
                     (int)(100.0f / e_total_project_source_count * si),
                     compile_time_ms / 1000.0f,
                     ANSI_RESET,
                     ANSI_LIGHT_GRAY,
                     get_name(),
                     ANSI_RESET,
                     success ? (ANSI_GRAY "Compiled" ANSI_GRAY) : (ANSI_RED "Failed to compile" ANSI_RESET),
                     ANSI_GRAY,
                     compile_unit_path,
                     msg.empty() ? (ANSI_RESET "") : (ANSI_RESET "\n"),
                     msg);

            if (success) {
                set_did_build();
            }
            s_source_index_mutex.unlock();

            // if (!success) {
            //     std::string cmd;
            //     for (auto& flag : compile_entry->compile_args)
            //         cmd += flag + " ";
            //     Log.critical("command: {}", cmd);
            // }

            if (!success) {
                error_reported = true;
            }
        };

        if (GlobalConfig::number_of_worker_threads() > 1) {
            const bool have_pch = compile_entries[0]->source_entry->is_pch();

            if (have_pch)
                compile(compile_entries[0]);

            if (!error_reported) {
                static constexpr bool USE_PARALLEL_EXEC = true;

                if (USE_PARALLEL_EXEC) {
                    std::for_each(std::execution::par_unseq,
                                  have_pch ? (compile_entries.begin() + 1) : compile_entries.begin(),
                                  compile_entries.end(),
                                  compile);
                } else {
                    auto workers          = FunctionWorker::create_workers(GlobalConfig::number_of_worker_threads());
                    auto compile_threaded = [&](const std::unique_ptr<CompileEntry>& ce) {
                        while (1 < 2) {
                            for (auto& w : workers) {
                                if (!w->is_busy()) {
                                    w->execute([&]() {
                                        compile(ce);
                                    });
                                    return;
                                }
                                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                            }
                        }
                    };

                    std::for_each(
                        have_pch ? (compile_entries.begin() + 1) : compile_entries.begin(), compile_entries.end(), compile_threaded);
                    for (auto& w : workers) {
                        while (w->is_busy()) {
                            std::this_thread::sleep_for(std::chrono::milliseconds(1));
                        }
                        w->terminate();
                    }
                }
            }
        } else {
            std::for_each(std::execution::seq, compile_entries.begin(), compile_entries.end(), compile);
        }

        if (error_reported) {
            throw std::runtime_error("Compilation failed");
        }
    }

    // Linking
    std::vector<std::filesystem::path> obj_paths;

    if (get_type() == Type::LIBRARY) {
        Log.trace("Archive [{}]", get_name());
        // Create link command and execute to link all compile_entries object files into library file
        std::vector<std::string> ar_flags;
        const auto arch_out_path = get_local_output_directory() / (get_name() + m_archiver->get_archive_extension());

        // delete archive if exists
        if (std::filesystem::exists(arch_out_path)) {
            std::filesystem::remove(arch_out_path);
        }

        m_archiver->load_archive_flags(ar_flags, arch_out_path);
        for (const auto& obj : get_output_object_paths()) {
            obj_paths.push_back(std::filesystem::weakly_canonical(obj));
        }
        const auto arg_file = get_local_output_directory() / (get_name() + "_ar_args.txt");
        // delete arg_file
        if (std::filesystem::exists(arg_file)) {
            std::filesystem::remove(arg_file);
        }
        // write cmd_entries line by line to arg file
        std::ofstream stream_arg_file(arg_file);
        for (const auto& ce : obj_paths) {
            stream_arg_file << FilesystemUtils::safe_path_string(ce.string()) << " ";
        }
        stream_arg_file.close();
        if (!arg_file.empty())
            m_archiver->load_input_flag_extension_file(ar_flags, arg_file);

        const auto [ret, msg] = execute_with_args(m_archiver->get_location(), ar_flags);
        if (ret != 0) {
            Log.error("Failed to archive [{}]:\n{}", get_name(), msg);
            // print archive command
            std::string arstr;
            for (auto& a : ar_flags) {
                arstr += a + " ";
            }
            Log.error("Command: {}", arstr);

            throw std::runtime_error("Failed to archive");
        }
    } else {
        Log.info("Link [{}]", get_name());
        const auto t1 = std::chrono::high_resolution_clock::now();

        // recursively iterate all libraries of get_libraries() and add .a paths to vector
        std::vector<std::string> library_paths;
        iterate_libs(this, library_paths);

        // create executable file from all lib and object files from this Component
        std::vector<std::string> link_flags;

        if (!m_linker_script_path.empty()) {
            // expand linker script path
            if (get_linker_script_path().is_relative()) {
                // if relative path, make it absolute and canonical
                m_linker_script_path = std::filesystem::weakly_canonical(get_root_path() / m_linker_script_path);
            } else {
                // make canonical
                m_linker_script_path = std::filesystem::weakly_canonical(m_linker_script_path);
            }
            if (!std::filesystem::exists(m_linker_script_path)) {
                Log.error("[{}] Linker script not found: {}", get_name(), m_linker_script_path);
                throw std::runtime_error("Linker script not found");
            }
        }

        const auto out_file = get_local_output_directory() / (get_name() + std::string(m_linker->get_executable_extension()));
        // delete out_file if exists
        if (std::filesystem::exists(out_file)) {
            std::filesystem::remove(out_file);
        }

        m_linker->load_link_flags(link_flags, out_file, get_linker_script_path());

        for (const auto& obj : get_output_object_paths()) {
            obj_paths.push_back(std::filesystem::weakly_canonical(obj));
        }

        const auto arg_file = get_local_output_directory() / (get_name() + "_link_args.txt");
        // delete arg_file
        if (std::filesystem::exists(arg_file)) {
            std::filesystem::remove(arg_file);
        }
        // write object paths to arg file
        std::ofstream stream_arg_file(arg_file);
        for (const auto& ce : obj_paths) {
            stream_arg_file << FilesystemUtils::safe_path_string(ce.string()) << " ";
        }
        stream_arg_file.close();
        if (!arg_file.empty())
            m_linker->load_input_flag_extension_file(link_flags, arg_file);

        for (const auto& lib : library_paths) {
            m_linker->load_input_flags(link_flags, lib);
        }
        for (const auto& flag : m_link_options) {
            prepare_and_push_flags(link_flags, flag);
        }

        for (const auto& flag : e_global_link_options[get_namespace()]) {
            prepare_and_push_flags(link_flags, flag);
        }

        const auto [ret, msg] = execute_with_args(m_linker->get_location(), link_flags);
        if (ret != 0) {
            std::string lfstr;
            for (auto& a : link_flags) {
                lfstr += a + " ";
            }
            Log.error("Failed to link [{}]:\n{}\nCommand: {}", get_name(), msg, lfstr);
            throw std::runtime_error("Failed to link");
        }

        const auto t2 = std::chrono::high_resolution_clock::now();
        auto ms       = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();
        Log.info(" - Link done in {:.3}s", ms / 1000.0f);
    }

    const auto& post_build_commands = get_commands("after-build");
    if (!post_build_commands.empty()) {
        for (const auto& commands : post_build_commands) {
            if (commands.list.empty())
                continue;

            Log.info("[{}] after-build \"{}\"", get_name(), commands.name);
            const auto [ret, msg] = execute_with_args("", commands.list, true);

            if (ret != 0) {
                std::string lstr;
                for (auto& a : commands.list) {
                    lstr += a + " ";
                }
                Log.error("[{}] after-build command failed:\n{}\nCommand: {}", get_name(), msg, lstr);
                throw std::runtime_error("after-build command failed");
            }
        }
    }

    const auto build_t2 = std::chrono::high_resolution_clock::now();
    auto build_ms       = std::chrono::duration_cast<std::chrono::milliseconds>(build_t2 - build_t1).count();
    Log.trace("Build done in {:.3}s", build_ms / 1000.0f);
}

std::vector<Component::SourceFilePath> Component::get_source_file_paths() {
    std::vector<SourceFilePath> source_file_paths;
    // Add requested paths
    for (auto& path : m_requested_sources) {
        // remove filter entries
        if (path[0] == '!') {
            const auto filt = path.substr(1);
            source_file_paths.erase(std::remove_if(source_file_paths.begin(),
                                                   source_file_paths.end(),
                                                   [&](const auto& sfp) {
                                                       const bool filtered = sfp.path.string().contains(filt);
                                                       if (filtered) {
                                                           Log.trace("Remove {} [filter = {}]", sfp.path, filt);
                                                       }
                                                       return filtered;
                                                   }),
                                    source_file_paths.end());
            continue;
        }

        // if path is relative, convert to absolute from component root directory
        if (path[0] == '.')
            path = std::filesystem::weakly_canonical(get_root_path() / path).string();

        // if path contains wildcards
        if (path.contains("*")) {
            // currently the only valid wildcards are *.extension for current folder match or **.extension for recursive match
            // This regex allows only *.ext or **.ext at the end of the path, no stars in the middle
            const bool valid_wildcard = RegexUtils::is_valid_wildcard(path);

            if (!valid_wildcard) {
                Log.error("Invalid source wildcard: {}", path);
                throw std::runtime_error("Invalid source wildcard");
            }

            const bool recursive_wildcard  = container_count(path, '*') == 2;
            const auto file_path           = std::filesystem::path(path);
            const bool is_inside_root_path = file_path.parent_path().string().starts_with(get_root_path().string());

            // TODO: check if wildcard parent paths exist on filesystem
            if (recursive_wildcard) {
                if (!is_inside_root_path) {
                    Log.error("[{}] Recursive add not available for external paths: {}", get_name(), file_path);
                    throw std::runtime_error("External path recursion");
                }

                Log.trace("[{}] Recursively add {} sources from {}", get_name(), file_path.extension(), file_path.parent_path());

                try {
                    // recurse file_path.parent_path and add files to source_file_paths that match file_path.extension
                    const auto ext = file_path.extension();
                    for (const auto& entry : std::filesystem::recursive_directory_iterator(file_path.parent_path())) {
                        if (entry.path().extension() == ext) {
                            source_file_paths.emplace_back(entry.path(), false);
                        }
                    }
                } catch (const std::exception& e) {
                    Log.error("[{}] Failed to recursively add sources from: \"{}\"\n{}", get_name(), file_path.parent_path(), e.what());
                    throw std::runtime_error("Failed to recursively add sources");
                }
            } else {
                Log.trace("[{}] Add {} sources from {}", get_name(), file_path.extension(), file_path.parent_path());
                try {
                    // check all files in file_path.parent_path non recursively and add files to source_file_paths that match file_path.extension
                    for (const auto& entry : std::filesystem::directory_iterator(file_path.parent_path())) {
                        if (entry.path().extension() == file_path.extension()) {
                            source_file_paths.emplace_back(entry.path(), !is_inside_root_path);
                        }
                    }
                } catch (const std::exception& e) {
                    Log.error("[{}] Failed to recursively add sources from: \"{}\"\n{}", get_name(), file_path.parent_path(), e.what());
                    throw std::runtime_error("Failed to recursively add sources");
                }
            }
        } else {
            // source is not in wildcard form
            if (std::filesystem::exists(path)) {
                const bool is_inside_root_path = std::filesystem::path(path).parent_path().string().starts_with(get_root_path().string());
                source_file_paths.emplace_back(path, !is_inside_root_path);
            } else {
                Log.error("[{}] Source \"{}\" not found", get_name(), path);
                throw std::runtime_error("Source not found");
            }
        }
    }

    return source_file_paths;
}

void Component::lua_add_sources(lua_State* L) {
    const auto push_source = [&](const std::string& src) {
        if (src.length() && src[0] == '!') {
            // Log.trace("[{}] Add filter: {}", get_name(), src);
            m_requested_sources.push_back(src);
        } else {
            Log.trace("[{}] Add source: {}", get_name(), src);
            // convert to absolute path from s_script_path_stack if relative
            if (src[0] == '.') {
                m_requested_sources.push_back(std::filesystem::weakly_canonical(s_script_path_stack.back() / src).string());
            } else {
                m_requested_sources.push_back(src);
            }
        }
    };

    auto arg_sources = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    if (arg_sources.isTable()) {
        for (int i = 1; i <= arg_sources.length(); i++) {
            auto src = arg_sources.rawget(i);
            if (src.isString()) {
                push_source(src.tostring());
            } else {
                luaL_error(L, "Source #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Source is not a string");
            }
        }
    } else if (arg_sources.isString()) {
        push_source(arg_sources.tostring());
    } else {
        luaL_error(L, "Invalid sources argument: \"{}\"", lua_typename(L, arg_sources.type()));
        throw std::runtime_error("Invalid sources argument");
    }
}

void Component::lua_add_include_paths(lua_State* L) {
    const auto arg_visibility = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));

    if (!LuaBackend::is_valid_visibility(arg_visibility)) {
        luaL_error(L,
                   "Invalid include paths visibility argument: type \"%s\" (%s)\n%s",
                   lua_typename(L, arg_visibility.type()),
                   arg_visibility.tostring().c_str(),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_INCLUDE_PATHS));
        throw std::runtime_error("Invalid include paths visibility argument");
    }

    const auto arg_sources = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(1));
    if (arg_sources.isTable()) {
        for (int i = 1; i <= arg_sources.length(); i++) {
            auto src = arg_sources.rawget(i);
            if (src.isString()) {
                const auto visibility_value     = LuaBackend::string_to_visibility(arg_visibility.tostring());
                m_visibility_mask_include_paths = m_visibility_mask_include_paths | visibility_value;

                // convert to absolute path from s_script_path_stack if relative
                if (src[0] == '.') {
                    m_include_paths.emplace_back(visibility_value,
                                                 std::filesystem::weakly_canonical(s_script_path_stack.back() / src).string());
                } else {
                    m_include_paths.emplace_back(visibility_value, src.tostring());
                }
            } else {
                luaL_error(L, "Include directory #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Include directory is not a string");
            }
        }
    } else if (arg_sources.isString()) {
        const auto visibility_value     = LuaBackend::string_to_visibility(arg_visibility.tostring());
        m_visibility_mask_include_paths = m_visibility_mask_include_paths | visibility_value;
        const auto str                  = arg_sources.tostring();

        // convert to absolute path from s_script_path_stack if relative
        if (str[0] == '.') {
            m_include_paths.emplace_back(visibility_value, std::filesystem::weakly_canonical(s_script_path_stack.back() / str).string());
        } else {
            m_include_paths.emplace_back(visibility_value, str);
        }
    } else {
        luaL_error(L,
                   "Invalid include paths argument: type \"%s\"\n%s",
                   lua_typename(L, arg_sources.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_INCLUDE_PATHS));
        throw std::runtime_error("Invalid include paths argument");
    }

    for (auto& dir : m_include_paths) {
        // check if dir is relative path
        if (dir.value.is_relative()) {
            // if relative path, make it absolute and canonical
            dir.value = std::filesystem::weakly_canonical(get_root_path() / dir.value);
        } else {
            // make canonical
            dir.value = std::filesystem::weakly_canonical(dir.value);
        }
    }

    // remove duplicates
    // std::sort(m_include_paths.begin(), m_include_paths.end());
    // m_include_paths.erase(std::unique(m_include_paths.begin(), m_include_paths.end()), m_include_paths.end());
}

void Component::lua_add_definitions(lua_State* L) {
    const auto arg_visibility = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));

    if (!LuaBackend::is_valid_visibility(arg_visibility)) {
        luaL_error(L,
                   "Invalid definitions visibility argument: type \"%s\"\n%s",
                   lua_typename(L, arg_visibility.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_DEFINITIONS));
        throw std::runtime_error("Invalid definitions visibility argument");
    }

    auto arg_sources = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(1));
    if (arg_sources.isTable()) {
        for (int i = 1; i <= arg_sources.length(); i++) {
            auto src = arg_sources.rawget(i);
            if (src.isString()) {
                const auto visibility_value   = LuaBackend::string_to_visibility(arg_visibility.tostring());
                m_visibility_mask_definitions = m_visibility_mask_definitions | visibility_value;
                m_definitions.emplace_back(visibility_value, src.tostring());
            } else {
                luaL_error(L, "Definition #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Definition is not a string");
            }
        }
    } else if (arg_sources.isString()) {
        const auto visibility_value   = LuaBackend::string_to_visibility(arg_visibility.tostring());
        m_visibility_mask_definitions = m_visibility_mask_definitions | visibility_value;
        m_definitions.emplace_back(visibility_value, arg_sources.tostring());
    } else {
        luaL_error(L,
                   "Invalid definitions argument: type \"%s\"\n%s",
                   lua_typename(L, arg_sources.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_DEFINITIONS));
        throw std::runtime_error("Invalid definitions argument");
    }

    // remove duplicates
    // std::sort(m_definitions.begin(), m_definitions.end());
    // m_definitions.erase(std::unique(m_definitions.begin(), m_definitions.end()), m_definitions.end());
}

void Component::lua_add_compile_options(lua_State* L) {
    const auto arg_visibility = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));

    if (!LuaBackend::is_valid_visibility(arg_visibility)) {
        luaL_error(L,
                   "Invalid compile options visibility argument: type \"%s\"\n%s",
                   lua_typename(L, arg_visibility.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_COMPILE_OPTIONS));
        throw std::runtime_error("Invalid compile options visibility argument");
    }

    auto arg_sources = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(1));
    if (arg_sources.isTable()) {
        for (int i = 1; i <= arg_sources.length(); i++) {
            auto src = arg_sources.rawget(i);
            if (src.isString()) {
                const auto visibility_value       = LuaBackend::string_to_visibility(arg_visibility.tostring());
                m_visibility_mask_compile_options = m_visibility_mask_compile_options | visibility_value;
                m_compile_options.emplace_back(visibility_value, src.tostring());
            } else {
                luaL_error(L, "Compile option #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Compile option is not a string");
            }
        }
    } else if (arg_sources.isString()) {
        const auto visibility_value       = LuaBackend::string_to_visibility(arg_visibility.tostring());
        m_visibility_mask_compile_options = m_visibility_mask_compile_options | visibility_value;
        m_compile_options.emplace_back(visibility_value, arg_sources.tostring());
    } else {
        luaL_error(L,
                   "Invalid compile options argument: type \"%s\"\n%s",
                   lua_typename(L, arg_sources.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_ADD_COMPILE_OPTIONS));
        throw std::runtime_error("Invalid compile options argument");
    }

    // remove duplicates
    // std::sort(m_compile_options.begin(), m_compile_options.end());
    // m_compile_options.erase(std::unique(m_compile_options.begin(), m_compile_options.end()), m_compile_options.end());
}

void Component::lua_set_linker_script(lua_State* L) {
    auto script_path = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    if (script_path.isString()) {
        Log.trace("[{}] Set linker script: {}", get_name(), script_path.tostring());
        m_linker_script_path = script_path.tostring();
    } else {
        luaL_error(L,
                   "Invalid linker script argument: type \"%s\"\n%s",
                   lua_typename(L, script_path.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_SET_LINKER_SCRIPT));
        throw std::runtime_error("Invalid linker script argument");
    }
}

void Component::lua_add_libraries(lua_State* L) {
    auto arg_libs = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));

    if (arg_libs.isTable()) {
        for (int i = 1; i <= arg_libs.length(); i++) {
            auto lib = arg_libs.rawget(i);
            if (lib.isInstance<Component>()) {
                auto component = lib.cast<Component*>();
                if (this == component) {
                    luaL_error(L, "Component #%d - trying to add self as a library", i);
                    throw std::runtime_error("Trying to add self as a library");
                }
                if (component->get_type() != Component::Type::LIBRARY) {
                    luaL_error(L,
                               "Component #%d is not a library [\"%s\" (%s)]",
                               i,
                               component->get_name().c_str(),
                               to_string(component->get_type()));
                    throw std::runtime_error("Added component not a library");
                }
                add_library(component);
            } else if (get_type() == Type::LIBRARY && arg_libs.isString()) {
                // add lib path
                std::filesystem::path lib_path = arg_libs.tostring();
                // convert to absolute if relative
                if (lib_path.is_relative()) {
                    lib_path = std::filesystem::weakly_canonical(s_script_path_stack.back() / lib_path);
                }
                m_additional_libraries.push_back(lib_path.string());
            } else {
                luaL_error(L, "Component #%d is not a valid library [%s]", i, lua_typename(L, lib.type()));
                throw std::runtime_error("Add invalid library");
            }
        }
    } else {
        if (arg_libs.isInstance<Component>()) {
            auto component = arg_libs.cast<Component*>();
            if (this == component) {
                luaL_error(L, "Trying to add self as a library");
                throw std::runtime_error("Trying to add self as a library");
            }
            if (component->get_type() != Component::Type::LIBRARY) {
                luaL_error(L, "Component is not a library [\"%s\" (%s)]", component->get_name().c_str(), to_string(component->get_type()));
                throw std::runtime_error("Added component not a library");
            }
            add_library(component);
        } else if (get_type() == Type::LIBRARY && arg_libs.isString()) {
            // add lib path
            std::filesystem::path lib_path = arg_libs.tostring();
            // convert to absolute if relative
            if (lib_path.is_relative()) {
                lib_path = std::filesystem::weakly_canonical(s_script_path_stack.back() / lib_path);
            }
            m_additional_libraries.push_back(lib_path.string());
        } else {
            luaL_error(L, "Invalid library");
            throw std::runtime_error("Add invalid library");
        }
    }
}

void Component::lua_add_link_options(lua_State* L) {
    auto arg_sources = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    if (arg_sources.isTable()) {
        for (int i = 1; i <= arg_sources.length(); i++) {
            auto src = arg_sources.rawget(i);
            if (src.isString()) {
                m_link_options.emplace_back(src.tostring());
            } else {
                luaL_error(L, "Link option #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Link option is not a string");
            }
        }
    } else if (arg_sources.isString()) {
        m_link_options.emplace_back(arg_sources.tostring());
    } else {
        luaL_error(L,
                   "Invalid link options argument: type \"%s\"\n%s",
                   lua_typename(L, arg_sources.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::GLOBAL_ADD_COMPILE_OPTIONS));
        throw std::runtime_error("Invalid link options argument");
    }
}

// TODO: this is supposed to be a shared_ptr. Find a way to make it shared through Lua.
void Component::add_library(Component* component) {
    Log.trace("[{}] add library [{}]", get_name(), component->get_name());

    // skip duplicates
    if (std::find(get_libraries().begin(), get_libraries().end(), component) != get_libraries().end())
        return;

    // register that this component uses the added one
    component->add_user(this);
    // add to library list
    m_libraries.push_back(component);
}

void Component::add_user(Component* user) {
    // skip duplicates
    if (std::find(get_users().begin(), get_users().end(), user) != get_users().end())
        return;

    m_used_by.push_back(user);
}

luabridge::LuaRef Component::lua_get_git_info(lua_State* L) {
    GIT git(get_root_path());
    if (!git.is_git_repository()) {
        luaL_error(L, "Not a git repository");
    }

    // push table containing keys "branch" and "short_hash" to lua stack
    luabridge::LuaRef git_info = luabridge::newTable(L);
    git_info["branch"]         = git.get_current_branch();
    git_info["short_hash"]     = git.get_current_short_hash();
    return git_info;
}

std::string Component::lua_get_root_path() { return get_root_path().string(); }
std::string Component::lua_get_output_path() { return get_local_output_directory().string(); }

std::string Component::lua_get_name() { return get_name(); }

void Component::lua_create_precompiled_header(lua_State* L) {
    if (!m_precompiled_header.empty()) {
        luaL_error(L, "Precompiled header already created for this component");
        throw std::runtime_error("Precompiled header already created");
    }

    auto arg_includes = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    if (arg_includes.isTable()) {
        for (int i = 1; i <= arg_includes.length(); i++) {
            auto src = arg_includes.rawget(i);
            if (src.isString()) {
                m_precompiled_header.emplace_back(src.tostring());
            } else {
                luaL_error(L, "Precompiled header include #%d is not a string [%s]", i, lua_typename(L, src.type()));
                throw std::runtime_error("Precompiled header include is not a string");
            }
        }
    } else {
        luaL_error(L,
                   "Invalid precompiled header list argument: type \"%s\"\n%s",
                   lua_typename(L, arg_includes.type()),
                   LuaBackend::get_script_help_string(LuaBackend::HelpEntry::COMPONENT_CREATE_PRECOMPILED_HEADER));
        throw std::runtime_error("Invalid precompiled header list argument");
    }
}

void Component::lua_set_compile_option_replacement(lua_State* L) {
    auto arg_match   = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    auto arg_search  = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(1));
    auto arg_replace = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(2));

    if (arg_match.isString() && arg_search.isString() && arg_replace.isString()) {
        m_compile_option_replacements.emplace_back(arg_match.tostring(), arg_search.tostring(), arg_replace.tostring());
    } else {
        luaL_error(L, "Invalid compile option replacement args");
    }
}

void Component::lua_add_command(lua_State* L) {
    const auto arg_type        = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(0));
    const auto arg_name        = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(1));
    const auto arg_commandline = luabridge::LuaRef::fromStack(L, LUA_FUNCTION_ARG_COMPONENT_OFFSET(2));

    if (!arg_type.isString() || arg_type.tostring() != "after-build") {
        const auto str = arg_type.tostring();
        luaL_error(L, "Invalid command type [%s] (types = \"after-build\")", str.c_str());
        throw std::logic_error("Invalid command type");
    }
    if (!arg_name.isString()) {
        luaL_error(L, "Invalid command name type [%s]", lua_typename(L, arg_name.type()));
        throw std::logic_error("Invalid command type");
    }
    if (!arg_commandline.isTable()) {
        luaL_error(L, "Command entry argument is not a table/list");
        throw std::logic_error("Invalid command entry list type");
    }

    std::vector<std::string> cmd;
    for (int i = 1; i <= arg_commandline.length(); i++) {
        auto src = arg_commandline.rawget(i);
        if (src.isString()) {
            cmd.push_back(src.tostring());
        } else {
            luaL_error(L, "Command entry #%d is not a string [%s]", i, lua_typename(L, src.type()));
            throw std::runtime_error("Command entry is not a string");
        }
    }

    m_commands[arg_type.tostring()].push_back({arg_name.tostring(), cmd});
}